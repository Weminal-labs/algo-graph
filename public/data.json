{
    "name": "auction-demo",
    "children": [
        {
            "name": ".gitignore",
            "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n.python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# Compiled smart contracts\n*.teal\n*.teal.tok\n\n_sandbox/\n"
        },
        {
            "name": ".travis.yml",
            "content": "dist: focal\nlanguage: python\n\npython:\n  - 3.9\n\ninstall:\n  - pip install -r requirements.txt\n\nbefore_script:\n  - ./sandbox up -v\n\nscript:\n  - black --check .\n  - pytest\n"
        },
        {
            "name": "README.md",
            "content": "# Algorand Auction Demo\n\nThis demo is an on-chain NFT auction using smart contracts on the Algorand blockchain.\n\n## Usage\n\nThe file `auction/operations.py` provides a set of functions that can be used to create and interact\nwith auctions. See that file for documentation.\n\n## Development Setup\n\nThis repo requires Python 3.6 or higher. We recommend you use a Python virtual environment to install\nthe required dependencies.\n\nSet up venv (one time):\n * `python3 -m venv venv`\n\nActive venv:\n * `. venv/bin/activate` (if your shell is bash/zsh)\n * `. venv/bin/activate.fish` (if your shell is fish)\n\nInstall dependencies:\n* `pip install -r requirements.txt`\n\nRun tests:\n* First, start an instance of [sandbox](https://github.com/algorand/sandbox) (requires Docker): `./sandbox up nightly`\n* `pytest`\n* When finished, the sandbox can be stopped with `./sandbox down`\n\nFormat code:\n* `black .`\n"
        },
        {
            "name": "auction",
            "children": [
                {
                    "name": "__init__.py",
                    "content": ""
                },
                {
                    "name": "account.py",
                    "content": "from algosdk import account, mnemonic\n\n\nclass Account:\n    \"\"\"Represents a private key and address for an Algorand account\"\"\"\n\n    def __init__(self, privateKey: str) -> None:\n        self.sk = privateKey\n        self.addr = account.address_from_private_key(privateKey)\n\n    def getAddress(self) -> str:\n        return self.addr\n\n    def getPrivateKey(self) -> str:\n        return self.sk\n\n    def getMnemonic(self) -> str:\n        return mnemonic.from_private_key(self.sk)\n\n    @classmethod\n    def FromMnemonic(cls, m: str) -> \"Account\":\n        return cls(mnemonic.to_private_key(m))\n"
                },
                {
                    "name": "contracts.py",
                    "content": "from pyteal import *\n\n\ndef approval_program():\n    seller_key = Bytes(\"seller\")\n    nft_id_key = Bytes(\"nft_id\")\n    start_time_key = Bytes(\"start\")\n    end_time_key = Bytes(\"end\")\n    reserve_amount_key = Bytes(\"reserve_amount\")\n    min_bid_increment_key = Bytes(\"min_bid_inc\")\n    num_bids_key = Bytes(\"num_bids\")\n    lead_bid_amount_key = Bytes(\"bid_amount\")\n    lead_bid_account_key = Bytes(\"bid_account\")\n\n    @Subroutine(TealType.none)\n    def closeNFTTo(assetID: Expr, account: Expr) -> Expr:\n        asset_holding = AssetHolding.balance(\n            Global.current_application_address(), assetID\n        )\n        return Seq(\n            asset_holding,\n            If(asset_holding.hasValue()).Then(\n                Seq(\n                    InnerTxnBuilder.Begin(),\n                    InnerTxnBuilder.SetFields(\n                        {\n                            TxnField.type_enum: TxnType.AssetTransfer,\n                            TxnField.xfer_asset: assetID,\n                            TxnField.asset_close_to: account,\n                        }\n                    ),\n                    InnerTxnBuilder.Submit(),\n                )\n            ),\n        )\n\n    @Subroutine(TealType.none)\n    def repayPreviousLeadBidder(prevLeadBidder: Expr, prevLeadBidAmount: Expr) -> Expr:\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.type_enum: TxnType.Payment,\n                    TxnField.amount: prevLeadBidAmount - Global.min_txn_fee(),\n                    TxnField.receiver: prevLeadBidder,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @Subroutine(TealType.none)\n    def closeAccountTo(account: Expr) -> Expr:\n        return If(Balance(Global.current_application_address()) != Int(0)).Then(\n            Seq(\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields(\n                    {\n                        TxnField.type_enum: TxnType.Payment,\n                        TxnField.close_remainder_to: account,\n                    }\n                ),\n                InnerTxnBuilder.Submit(),\n            )\n        )\n\n    on_create_start_time = Btoi(Txn.application_args[2])\n    on_create_end_time = Btoi(Txn.application_args[3])\n    on_create = Seq(\n        App.globalPut(seller_key, Txn.application_args[0]),\n        App.globalPut(nft_id_key, Btoi(Txn.application_args[1])),\n        App.globalPut(start_time_key, on_create_start_time),\n        App.globalPut(end_time_key, on_create_end_time),\n        App.globalPut(reserve_amount_key, Btoi(Txn.application_args[4])),\n        App.globalPut(min_bid_increment_key, Btoi(Txn.application_args[5])),\n        App.globalPut(lead_bid_account_key, Global.zero_address()),\n        Assert(\n            And(\n                Global.latest_timestamp() < on_create_start_time,\n                on_create_start_time < on_create_end_time,\n                # TODO: should we impose a maximum auction length?\n            )\n        ),\n        Approve(),\n    )\n\n    on_setup = Seq(\n        Assert(Global.latest_timestamp() < App.globalGet(start_time_key)),\n        # opt into NFT asset -- because you can't opt in if you're already opted in, this is what\n        # we'll use to make sure the contract has been set up\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.globalGet(nft_id_key),\n                TxnField.asset_receiver: Global.current_application_address(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        Approve(),\n    )\n\n    on_bid_txn_index = Txn.group_index() - Int(1)\n    on_bid_nft_holding = AssetHolding.balance(\n        Global.current_application_address(), App.globalGet(nft_id_key)\n    )\n    on_bid = Seq(\n        on_bid_nft_holding,\n        Assert(\n            And(\n                # the auction has been set up\n                on_bid_nft_holding.hasValue(),\n                on_bid_nft_holding.value() > Int(0),\n                # the auction has started\n                App.globalGet(start_time_key) <= Global.latest_timestamp(),\n                # the auction has not ended\n                Global.latest_timestamp() < App.globalGet(end_time_key),\n                # the actual bid payment is before the app call\n                Gtxn[on_bid_txn_index].type_enum() == TxnType.Payment,\n                Gtxn[on_bid_txn_index].sender() == Txn.sender(),\n                Gtxn[on_bid_txn_index].receiver()\n                == Global.current_application_address(),\n                Gtxn[on_bid_txn_index].amount() >= Global.min_txn_fee(),\n            )\n        ),\n        If(\n            Gtxn[on_bid_txn_index].amount()\n            >= App.globalGet(lead_bid_amount_key) + App.globalGet(min_bid_increment_key)\n        ).Then(\n            Seq(\n                If(App.globalGet(lead_bid_account_key) != Global.zero_address()).Then(\n                    repayPreviousLeadBidder(\n                        App.globalGet(lead_bid_account_key),\n                        App.globalGet(lead_bid_amount_key),\n                    )\n                ),\n                App.globalPut(lead_bid_amount_key, Gtxn[on_bid_txn_index].amount()),\n                App.globalPut(lead_bid_account_key, Gtxn[on_bid_txn_index].sender()),\n                App.globalPut(num_bids_key, App.globalGet(num_bids_key) + Int(1)),\n                Approve(),\n            )\n        ),\n        Reject(),\n    )\n\n    on_call_method = Txn.application_args[0]\n    on_call = Cond(\n        [on_call_method == Bytes(\"setup\"), on_setup],\n        [on_call_method == Bytes(\"bid\"), on_bid],\n    )\n\n    on_delete = Seq(\n        If(Global.latest_timestamp() < App.globalGet(start_time_key)).Then(\n            Seq(\n                # the auction has not yet started, it's ok to delete\n                Assert(\n                    Or(\n                        # sender must either be the seller or the auction creator\n                        Txn.sender() == App.globalGet(seller_key),\n                        Txn.sender() == Global.creator_address(),\n                    )\n                ),\n                # if the auction contract account has opted into the nft, close it out\n                closeNFTTo(App.globalGet(nft_id_key), App.globalGet(seller_key)),\n                # if the auction contract still has funds, send them all to the seller\n                closeAccountTo(App.globalGet(seller_key)),\n                Approve(),\n            )\n        ),\n        If(App.globalGet(end_time_key) <= Global.latest_timestamp()).Then(\n            Seq(\n                # the auction has ended, pay out assets\n                If(App.globalGet(lead_bid_account_key) != Global.zero_address())\n                .Then(\n                    If(\n                        App.globalGet(lead_bid_amount_key)\n                        >= App.globalGet(reserve_amount_key)\n                    )\n                    .Then(\n                        # the auction was successful: send lead bid account the nft\n                        closeNFTTo(\n                            App.globalGet(nft_id_key),\n                            App.globalGet(lead_bid_account_key),\n                        )\n                    )\n                    .Else(\n                        Seq(\n                            # the auction was not successful because the reserve was not met: return\n                            # the nft to the seller and repay the lead bidder\n                            closeNFTTo(\n                                App.globalGet(nft_id_key), App.globalGet(seller_key)\n                            ),\n                            repayPreviousLeadBidder(\n                                App.globalGet(lead_bid_account_key),\n                                App.globalGet(lead_bid_amount_key),\n                            ),\n                        )\n                    )\n                )\n                .Else(\n                    # the auction was not successful because no bids were placed: return the nft to the seller\n                    closeNFTTo(App.globalGet(nft_id_key), App.globalGet(seller_key))\n                ),\n                # send remaining funds to the seller\n                closeAccountTo(App.globalGet(seller_key)),\n                Approve(),\n            )\n        ),\n        Reject(),\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_call],\n        [\n            Txn.on_completion() == OnComplete.DeleteApplication,\n            on_delete,\n        ],\n        [\n            Or(\n                Txn.on_completion() == OnComplete.OptIn,\n                Txn.on_completion() == OnComplete.CloseOut,\n                Txn.on_completion() == OnComplete.UpdateApplication,\n            ),\n            Reject(),\n        ],\n    )\n\n    return program\n\n\ndef clear_state_program():\n    return Approve()\n\n\nif __name__ == \"__main__\":\n    with open(\"auction_approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval_program(), mode=Mode.Application, version=5)\n        f.write(compiled)\n\n    with open(\"auction_clear_state.teal\", \"w\") as f:\n        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=5)\n        f.write(compiled)\n"
                },
                {
                    "name": "operations.py",
                    "content": "from typing import Tuple, List\n\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.future import transaction\nfrom algosdk.logic import get_application_address\nfrom algosdk import account, encoding\n\nfrom pyteal import compileTeal, Mode\n\nfrom .account import Account\nfrom .contracts import approval_program, clear_state_program\nfrom .util import (\n    waitForTransaction,\n    fullyCompileContract,\n    getAppGlobalState,\n)\n\nAPPROVAL_PROGRAM = b\"\"\nCLEAR_STATE_PROGRAM = b\"\"\n\n\ndef getContracts(client: AlgodClient) -> Tuple[bytes, bytes]:\n    \"\"\"Get the compiled TEAL contracts for the auction.\n\n    Args:\n        client: An algod client that has the ability to compile TEAL programs.\n\n    Returns:\n        A tuple of 2 byte strings. The first is the approval program, and the\n        second is the clear state program.\n    \"\"\"\n    global APPROVAL_PROGRAM\n    global CLEAR_STATE_PROGRAM\n\n    if len(APPROVAL_PROGRAM) == 0:\n        APPROVAL_PROGRAM = fullyCompileContract(client, approval_program())\n        CLEAR_STATE_PROGRAM = fullyCompileContract(client, clear_state_program())\n\n    return APPROVAL_PROGRAM, CLEAR_STATE_PROGRAM\n\n\ndef createAuctionApp(\n    client: AlgodClient,\n    sender: Account,\n    seller: str,\n    nftID: int,\n    startTime: int,\n    endTime: int,\n    reserve: int,\n    minBidIncrement: int,\n) -> int:\n    \"\"\"Create a new auction.\n\n    Args:\n        client: An algod client.\n        sender: The account that will create the auction application.\n        seller: The address of the seller that currently holds the NFT being\n            auctioned.\n        nftID: The ID of the NFT being auctioned.\n        startTime: A UNIX timestamp representing the start time of the auction.\n            This must be greater than the current UNIX timestamp.\n        endTime: A UNIX timestamp representing the end time of the auction. This\n            must be greater than startTime.\n        reserve: The reserve amount of the auction. If the auction ends without\n            a bid that is equal to or greater than this amount, the auction will\n            fail, meaning the bid amount will be refunded to the lead bidder and\n            the NFT will return to the seller.\n        minBidIncrement: The minimum different required between a new bid and\n            the current leading bid.\n\n    Returns:\n        The ID of the newly created auction app.\n    \"\"\"\n    approval, clear = getContracts(client)\n\n    globalSchema = transaction.StateSchema(num_uints=7, num_byte_slices=2)\n    localSchema = transaction.StateSchema(num_uints=0, num_byte_slices=0)\n\n    app_args = [\n        encoding.decode_address(seller),\n        nftID.to_bytes(8, \"big\"),\n        startTime.to_bytes(8, \"big\"),\n        endTime.to_bytes(8, \"big\"),\n        reserve.to_bytes(8, \"big\"),\n        minBidIncrement.to_bytes(8, \"big\"),\n    ]\n\n    txn = transaction.ApplicationCreateTxn(\n        sender=sender.getAddress(),\n        on_complete=transaction.OnComplete.NoOpOC,\n        approval_program=approval,\n        clear_program=clear,\n        global_schema=globalSchema,\n        local_schema=localSchema,\n        app_args=app_args,\n        sp=client.suggested_params(),\n    )\n\n    signedTxn = txn.sign(sender.getPrivateKey())\n\n    client.send_transaction(signedTxn)\n\n    response = waitForTransaction(client, signedTxn.get_txid())\n    assert response.applicationIndex is not None and response.applicationIndex > 0\n    return response.applicationIndex\n\n\ndef setupAuctionApp(\n    client: AlgodClient,\n    appID: int,\n    funder: Account,\n    nftHolder: Account,\n    nftID: int,\n    nftAmount: int,\n) -> None:\n    \"\"\"Finish setting up an auction.\n\n    This operation funds the app auction escrow account, opts that account into\n    the NFT, and sends the NFT to the escrow account, all in one atomic\n    transaction group. The auction must not have started yet.\n\n    The escrow account requires a total of 0.203 Algos for funding. See the code\n    below for a breakdown of this amount.\n\n    Args:\n        client: An algod client.\n        appID: The app ID of the auction.\n        funder: The account providing the funding for the escrow account.\n        nftHolder: The account holding the NFT.\n        nftID: The NFT ID.\n        nftAmount: The NFT amount being auctioned. Some NFTs has a total supply\n            of 1, while others are fractional NFTs with a greater total supply,\n            so use a value that makes sense for the NFT being auctioned.\n    \"\"\"\n    appAddr = get_application_address(appID)\n\n    suggestedParams = client.suggested_params()\n\n    fundingAmount = (\n        # min account balance\n        100_000\n        # additional min balance to opt into NFT\n        + 100_000\n        # 3 * min txn fee\n        + 3 * 1_000\n    )\n\n    fundAppTxn = transaction.PaymentTxn(\n        sender=funder.getAddress(),\n        receiver=appAddr,\n        amt=fundingAmount,\n        sp=suggestedParams,\n    )\n\n    setupTxn = transaction.ApplicationCallTxn(\n        sender=funder.getAddress(),\n        index=appID,\n        on_complete=transaction.OnComplete.NoOpOC,\n        app_args=[b\"setup\"],\n        foreign_assets=[nftID],\n        sp=suggestedParams,\n    )\n\n    fundNftTxn = transaction.AssetTransferTxn(\n        sender=nftHolder.getAddress(),\n        receiver=appAddr,\n        index=nftID,\n        amt=nftAmount,\n        sp=suggestedParams,\n    )\n\n    transaction.assign_group_id([fundAppTxn, setupTxn, fundNftTxn])\n\n    signedFundAppTxn = fundAppTxn.sign(funder.getPrivateKey())\n    signedSetupTxn = setupTxn.sign(funder.getPrivateKey())\n    signedFundNftTxn = fundNftTxn.sign(nftHolder.getPrivateKey())\n\n    client.send_transactions([signedFundAppTxn, signedSetupTxn, signedFundNftTxn])\n\n    waitForTransaction(client, signedFundAppTxn.get_txid())\n\n\ndef placeBid(client: AlgodClient, appID: int, bidder: Account, bidAmount: int) -> None:\n    \"\"\"Place a bid on an active auction.\n\n    Args:\n        client: An Algod client.\n        appID: The app ID of the auction.\n        bidder: The account providing the bid.\n        bidAmount: The amount of the bid.\n    \"\"\"\n    appAddr = get_application_address(appID)\n    appGlobalState = getAppGlobalState(client, appID)\n\n    nftID = appGlobalState[b\"nft_id\"]\n\n    if any(appGlobalState[b\"bid_account\"]):\n        # if \"bid_account\" is not the zero address\n        prevBidLeader = encoding.encode_address(appGlobalState[b\"bid_account\"])\n    else:\n        prevBidLeader = None\n\n    suggestedParams = client.suggested_params()\n\n    payTxn = transaction.PaymentTxn(\n        sender=bidder.getAddress(),\n        receiver=appAddr,\n        amt=bidAmount,\n        sp=suggestedParams,\n    )\n\n    appCallTxn = transaction.ApplicationCallTxn(\n        sender=bidder.getAddress(),\n        index=appID,\n        on_complete=transaction.OnComplete.NoOpOC,\n        app_args=[b\"bid\"],\n        foreign_assets=[nftID],\n        # must include the previous lead bidder here to the app can refund that bidder's payment\n        accounts=[prevBidLeader] if prevBidLeader is not None else [],\n        sp=suggestedParams,\n    )\n\n    transaction.assign_group_id([payTxn, appCallTxn])\n\n    signedPayTxn = payTxn.sign(bidder.getPrivateKey())\n    signedAppCallTxn = appCallTxn.sign(bidder.getPrivateKey())\n\n    client.send_transactions([signedPayTxn, signedAppCallTxn])\n\n    waitForTransaction(client, appCallTxn.get_txid())\n\n\ndef closeAuction(client: AlgodClient, appID: int, closer: Account):\n    \"\"\"Close an auction.\n\n    This action can only happen before an auction has begun, in which case it is\n    cancelled, or after an auction has ended.\n\n    If called after the auction has ended and the auction was successful, the\n    NFT is transferred to the winning bidder and the auction proceeds are\n    transferred to the seller. If the auction was not successful, the NFT and\n    all funds are transferred to the seller.\n\n    Args:\n        client: An Algod client.\n        appID: The app ID of the auction.\n        closer: The account initiating the close transaction. This must be\n            either the seller or auction creator if you wish to close the\n            auction before it starts. Otherwise, this can be any account.\n    \"\"\"\n    appGlobalState = getAppGlobalState(client, appID)\n\n    nftID = appGlobalState[b\"nft_id\"]\n\n    accounts: List[str] = [encoding.encode_address(appGlobalState[b\"seller\"])]\n\n    if any(appGlobalState[b\"bid_account\"]):\n        # if \"bid_account\" is not the zero address\n        accounts.append(encoding.encode_address(appGlobalState[b\"bid_account\"]))\n\n    deleteTxn = transaction.ApplicationDeleteTxn(\n        sender=closer.getAddress(),\n        index=appID,\n        accounts=accounts,\n        foreign_assets=[nftID],\n        sp=client.suggested_params(),\n    )\n    signedDeleteTxn = deleteTxn.sign(closer.getPrivateKey())\n\n    client.send_transaction(signedDeleteTxn)\n\n    waitForTransaction(client, signedDeleteTxn.get_txid())\n"
                },
                {
                    "name": "operations_test.py",
                    "content": "from time import time, sleep\n\nimport pytest\n\nfrom algosdk import account, encoding\nfrom algosdk.logic import get_application_address\n\nfrom .operations import createAuctionApp, setupAuctionApp, placeBid, closeAuction\nfrom .util import getBalances, getAppGlobalState, getLastBlockTimestamp\nfrom .testing.setup import getAlgodClient\nfrom .testing.resources import getTemporaryAccount, optInToAsset, createDummyAsset\n\n\ndef test_create():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    _, seller_addr = account.generate_account()  # random address\n\n    nftID = 1  # fake ID\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller_addr,\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    actual = getAppGlobalState(client, appID)\n    expected = {\n        b\"seller\": encoding.decode_address(seller_addr),\n        b\"nft_id\": nftID,\n        b\"start\": startTime,\n        b\"end\": endTime,\n        b\"reserve_amount\": reserve,\n        b\"min_bid_inc\": increment,\n        b\"bid_account\": bytes(32),  # decoded zero address\n    }\n\n    assert actual == expected\n\n\ndef test_setup():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    actualState = getAppGlobalState(client, appID)\n    expectedState = {\n        b\"seller\": encoding.decode_address(seller.getAddress()),\n        b\"nft_id\": nftID,\n        b\"start\": startTime,\n        b\"end\": endTime,\n        b\"reserve_amount\": reserve,\n        b\"min_bid_inc\": increment,\n        b\"bid_account\": bytes(32),  # decoded zero address\n    }\n\n    assert actualState == expectedState\n\n    actualBalances = getBalances(client, get_application_address(appID))\n    expectedBalances = {0: 2 * 100_000 + 2 * 1_000, nftID: nftAmount}\n\n    assert actualBalances == expectedBalances\n\n\ndef test_first_bid_before_start():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 5 * 60  # start time is 5 minutes in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    bidder = getTemporaryAccount(client)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    assert lastRoundTime < startTime\n\n    with pytest.raises(Exception):\n        bidAmount = 500_000  # 0.5 Algos\n        placeBid(client=client, appID=appID, bidder=bidder, bidAmount=bidAmount)\n\n\ndef test_first_bid():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    bidder = getTemporaryAccount(client)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < startTime + 5:\n        sleep(startTime + 5 - lastRoundTime)\n\n    bidAmount = 500_000  # 0.5 Algos\n    placeBid(client=client, appID=appID, bidder=bidder, bidAmount=bidAmount)\n\n    actualState = getAppGlobalState(client, appID)\n    expectedState = {\n        b\"seller\": encoding.decode_address(seller.getAddress()),\n        b\"nft_id\": nftID,\n        b\"start\": startTime,\n        b\"end\": endTime,\n        b\"reserve_amount\": reserve,\n        b\"min_bid_inc\": increment,\n        b\"num_bids\": 1,\n        b\"bid_amount\": bidAmount,\n        b\"bid_account\": encoding.decode_address(bidder.getAddress()),\n    }\n\n    assert actualState == expectedState\n\n    actualBalances = getBalances(client, get_application_address(appID))\n    expectedBalances = {0: 2 * 100_000 + 2 * 1_000 + bidAmount, nftID: nftAmount}\n\n    assert actualBalances == expectedBalances\n\n\ndef test_second_bid():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    bidder1 = getTemporaryAccount(client)\n    bidder2 = getTemporaryAccount(client)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < startTime + 5:\n        sleep(startTime + 5 - lastRoundTime)\n\n    bid1Amount = 500_000  # 0.5 Algos\n    placeBid(client=client, appID=appID, bidder=bidder1, bidAmount=bid1Amount)\n\n    bidder1AlgosBefore = getBalances(client, bidder1.getAddress())[0]\n\n    with pytest.raises(Exception):\n        bid2Amount = bid1Amount + 1_000  # increase is less than min increment amount\n        placeBid(\n            client=client,\n            appID=appID,\n            bidder=bidder2,\n            bidAmount=bid2Amount,\n        )\n\n    bid2Amount = bid1Amount + increment\n    placeBid(client=client, appID=appID, bidder=bidder2, bidAmount=bid2Amount)\n\n    actualState = getAppGlobalState(client, appID)\n    expectedState = {\n        b\"seller\": encoding.decode_address(seller.getAddress()),\n        b\"nft_id\": nftID,\n        b\"start\": startTime,\n        b\"end\": endTime,\n        b\"reserve_amount\": reserve,\n        b\"min_bid_inc\": increment,\n        b\"num_bids\": 2,\n        b\"bid_amount\": bid2Amount,\n        b\"bid_account\": encoding.decode_address(bidder2.getAddress()),\n    }\n\n    assert actualState == expectedState\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 2 * 100_000 + 2 * 1_000 + bid2Amount, nftID: nftAmount}\n\n    assert actualAppBalances == expectedAppBalances\n\n    bidder1AlgosAfter = getBalances(client, bidder1.getAddress())[0]\n\n    # bidder1 should receive a refund of their bid, minus the txn fee\n    assert bidder1AlgosAfter - bidder1AlgosBefore >= bid1Amount - 1_000\n\n\ndef test_close_before_start():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 5 * 60  # start time is 5 minutes in the future\n    endTime = startTime + 60  # end time is 1 minute after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    assert lastRoundTime < startTime\n\n    closeAuction(client, appID, seller)\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 0}\n\n    assert actualAppBalances == expectedAppBalances\n\n    sellerNftBalance = getBalances(client, seller.getAddress())[nftID]\n    assert sellerNftBalance == nftAmount\n\n\ndef test_close_no_bids():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 30  # end time is 30 seconds after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < endTime + 5:\n        sleep(endTime + 5 - lastRoundTime)\n\n    closeAuction(client, appID, seller)\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 0}\n\n    assert actualAppBalances == expectedAppBalances\n\n    sellerNftBalance = getBalances(client, seller.getAddress())[nftID]\n    assert sellerNftBalance == nftAmount\n\n\ndef test_close_reserve_not_met():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 30  # end time is 30 seconds after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    bidder = getTemporaryAccount(client)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < startTime + 5:\n        sleep(startTime + 5 - lastRoundTime)\n\n    bidAmount = 500_000  # 0.5 Algos\n    placeBid(client=client, appID=appID, bidder=bidder, bidAmount=bidAmount)\n\n    bidderAlgosBefore = getBalances(client, bidder.getAddress())[0]\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < endTime + 5:\n        sleep(endTime + 5 - lastRoundTime)\n\n    closeAuction(client, appID, seller)\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 0}\n\n    assert actualAppBalances == expectedAppBalances\n\n    bidderAlgosAfter = getBalances(client, bidder.getAddress())[0]\n\n    # bidder should receive a refund of their bid, minus the txn fee\n    assert bidderAlgosAfter - bidderAlgosBefore >= bidAmount - 1_000\n\n    sellerNftBalance = getBalances(client, seller.getAddress())[nftID]\n    assert sellerNftBalance == nftAmount\n\n\ndef test_close_reserve_met():\n    client = getAlgodClient()\n\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 30  # end time is 30 seconds after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n\n    sellerAlgosBefore = getBalances(client, seller.getAddress())[0]\n\n    bidder = getTemporaryAccount(client)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < startTime + 5:\n        sleep(startTime + 5 - lastRoundTime)\n\n    bidAmount = reserve\n    placeBid(client=client, appID=appID, bidder=bidder, bidAmount=bidAmount)\n\n    optInToAsset(client, nftID, bidder)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < endTime + 5:\n        sleep(endTime + 5 - lastRoundTime)\n\n    closeAuction(client, appID, seller)\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 0}\n\n    assert actualAppBalances == expectedAppBalances\n\n    bidderNftBalance = getBalances(client, bidder.getAddress())[nftID]\n\n    assert bidderNftBalance == nftAmount\n\n    actualSellerBalances = getBalances(client, seller.getAddress())\n\n    assert len(actualSellerBalances) == 2\n    # seller should receive the bid amount, minus the txn fee\n    assert actualSellerBalances[0] >= sellerAlgosBefore + bidAmount - 1_000\n    assert actualSellerBalances[nftID] == 0\n"
                },
                {
                    "name": "testing",
                    "children": [
                        {
                            "name": "__init__.py",
                            "content": ""
                        },
                        {
                            "name": "resources.py",
                            "content": "from typing import List\nfrom random import choice, randint\n\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.future import transaction\nfrom algosdk import account\n\nfrom ..account import Account\nfrom ..util import PendingTxnResponse, waitForTransaction\nfrom .setup import getGenesisAccounts\n\n\ndef payAccount(\n    client: AlgodClient, sender: Account, to: str, amount: int\n) -> PendingTxnResponse:\n    txn = transaction.PaymentTxn(\n        sender=sender.getAddress(),\n        receiver=to,\n        amt=amount,\n        sp=client.suggested_params(),\n    )\n    signedTxn = txn.sign(sender.getPrivateKey())\n\n    client.send_transaction(signedTxn)\n    return waitForTransaction(client, signedTxn.get_txid())\n\n\nFUNDING_AMOUNT = 100_000_000\n\n\ndef fundAccount(\n    client: AlgodClient, address: str, amount: int = FUNDING_AMOUNT\n) -> PendingTxnResponse:\n    fundingAccount = choice(getGenesisAccounts())\n    return payAccount(client, fundingAccount, address, amount)\n\n\naccountList: List[Account] = []\n\n\ndef getTemporaryAccount(client: AlgodClient) -> Account:\n    global accountList\n\n    if len(accountList) == 0:\n        sks = [account.generate_account()[0] for i in range(16)]\n        accountList = [Account(sk) for sk in sks]\n\n        genesisAccounts = getGenesisAccounts()\n        suggestedParams = client.suggested_params()\n\n        txns: List[transaction.Transaction] = []\n        for i, a in enumerate(accountList):\n            fundingAccount = genesisAccounts[i % len(genesisAccounts)]\n            txns.append(\n                transaction.PaymentTxn(\n                    sender=fundingAccount.getAddress(),\n                    receiver=a.getAddress(),\n                    amt=FUNDING_AMOUNT,\n                    sp=suggestedParams,\n                )\n            )\n\n        txns = transaction.assign_group_id(txns)\n        signedTxns = [\n            txn.sign(genesisAccounts[i % len(genesisAccounts)].getPrivateKey())\n            for i, txn in enumerate(txns)\n        ]\n\n        client.send_transactions(signedTxns)\n\n        waitForTransaction(client, signedTxns[0].get_txid())\n\n    return accountList.pop()\n\n\ndef optInToAsset(\n    client: AlgodClient, assetID: int, account: Account\n) -> PendingTxnResponse:\n    txn = transaction.AssetOptInTxn(\n        sender=account.getAddress(),\n        index=assetID,\n        sp=client.suggested_params(),\n    )\n    signedTxn = txn.sign(account.getPrivateKey())\n\n    client.send_transaction(signedTxn)\n    return waitForTransaction(client, signedTxn.get_txid())\n\n\ndef createDummyAsset(client: AlgodClient, total: int, account: Account = None) -> int:\n    if account is None:\n        account = getTemporaryAccount(client)\n\n    randomNumber = randint(0, 999)\n    # this random note reduces the likelihood of this transaction looking like a duplicate\n    randomNote = bytes(randint(0, 255) for _ in range(20))\n\n    txn = transaction.AssetCreateTxn(\n        sender=account.getAddress(),\n        total=total,\n        decimals=0,\n        default_frozen=False,\n        manager=account.getAddress(),\n        reserve=account.getAddress(),\n        freeze=account.getAddress(),\n        clawback=account.getAddress(),\n        unit_name=f\"D{randomNumber}\",\n        asset_name=f\"Dummy {randomNumber}\",\n        url=f\"https://dummy.asset/{randomNumber}\",\n        note=randomNote,\n        sp=client.suggested_params(),\n    )\n    signedTxn = txn.sign(account.getPrivateKey())\n\n    client.send_transaction(signedTxn)\n\n    response = waitForTransaction(client, signedTxn.get_txid())\n    assert response.assetIndex is not None and response.assetIndex > 0\n    return response.assetIndex\n"
                        },
                        {
                            "name": "setup.py",
                            "content": "from typing import Optional, List\n\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.kmd import KMDClient\n\nfrom ..account import Account\n\nALGOD_ADDRESS = \"http://localhost:4001\"\nALGOD_TOKEN = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\ndef getAlgodClient() -> AlgodClient:\n    return AlgodClient(ALGOD_TOKEN, ALGOD_ADDRESS)\n\n\nKMD_ADDRESS = \"http://localhost:4002\"\nKMD_TOKEN = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\ndef getKmdClient() -> KMDClient:\n    return KMDClient(KMD_TOKEN, KMD_ADDRESS)\n\n\nKMD_WALLET_NAME = \"unencrypted-default-wallet\"\nKMD_WALLET_PASSWORD = \"\"\n\nkmdAccounts: Optional[List[Account]] = None\n\n\ndef getGenesisAccounts() -> List[Account]:\n    global kmdAccounts\n\n    if kmdAccounts is None:\n        kmd = getKmdClient()\n\n        wallets = kmd.list_wallets()\n        walletID = None\n        for wallet in wallets:\n            if wallet[\"name\"] == KMD_WALLET_NAME:\n                walletID = wallet[\"id\"]\n                break\n\n        if walletID is None:\n            raise Exception(\"Wallet not found: {}\".format(KMD_WALLET_NAME))\n\n        walletHandle = kmd.init_wallet_handle(walletID, KMD_WALLET_PASSWORD)\n\n        try:\n            addresses = kmd.list_keys(walletHandle)\n            privateKeys = [\n                kmd.export_key(walletHandle, KMD_WALLET_PASSWORD, addr)\n                for addr in addresses\n            ]\n            kmdAccounts = [Account(sk) for sk in privateKeys]\n        finally:\n            kmd.release_wallet_handle(walletHandle)\n\n    return kmdAccounts\n"
                        },
                        {
                            "name": "setup_test.py",
                            "content": "import base64\n\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.kmd import KMDClient\nfrom algosdk import encoding\n\nfrom .setup import getAlgodClient, getKmdClient, getGenesisAccounts\n\n\ndef test_getAlgodClient():\n    client = getAlgodClient()\n    assert isinstance(client, AlgodClient)\n\n    response = client.health()\n    assert response is None\n\n\ndef test_getKmdClient():\n    client = getKmdClient()\n    assert isinstance(client, KMDClient)\n\n    response = client.versions()\n    expected = [\"v1\"]\n    assert response == expected\n\n\ndef test_getGenesisAccounts():\n    accounts = getGenesisAccounts()\n\n    assert len(accounts) == 3\n    assert all(encoding.is_valid_address(account.getAddress()) for account in accounts)\n    assert all(\n        len(base64.b64decode(account.getPrivateKey())) == 64 for account in accounts\n    )\n"
                        }
                    ]
                },
                {
                    "name": "util.py",
                    "content": "from typing import List, Tuple, Dict, Any, Optional, Union\nfrom base64 import b64decode\n\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk import encoding\n\nfrom pyteal import compileTeal, Mode, Expr\n\nfrom .account import Account\n\n\nclass PendingTxnResponse:\n    def __init__(self, response: Dict[str, Any]) -> None:\n        self.poolError: str = response[\"pool-error\"]\n        self.txn: Dict[str, Any] = response[\"txn\"]\n\n        self.applicationIndex: Optional[int] = response.get(\"application-index\")\n        self.assetIndex: Optional[int] = response.get(\"asset-index\")\n        self.closeRewards: Optional[int] = response.get(\"close-rewards\")\n        self.closingAmount: Optional[int] = response.get(\"closing-amount\")\n        self.confirmedRound: Optional[int] = response.get(\"confirmed-round\")\n        self.globalStateDelta: Optional[Any] = response.get(\"global-state-delta\")\n        self.localStateDelta: Optional[Any] = response.get(\"local-state-delta\")\n        self.receiverRewards: Optional[int] = response.get(\"receiver-rewards\")\n        self.senderRewards: Optional[int] = response.get(\"sender-rewards\")\n\n        self.innerTxns: List[Any] = response.get(\"inner-txns\", [])\n        self.logs: List[bytes] = [b64decode(l) for l in response.get(\"logs\", [])]\n\n\ndef waitForTransaction(\n    client: AlgodClient, txID: str, timeout: int = 10\n) -> PendingTxnResponse:\n    lastStatus = client.status()\n    lastRound = lastStatus[\"last-round\"]\n    startRound = lastRound\n\n    while lastRound < startRound + timeout:\n        pending_txn = client.pending_transaction_info(txID)\n\n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return PendingTxnResponse(pending_txn)\n\n        if pending_txn[\"pool-error\"]:\n            raise Exception(\"Pool error: {}\".format(pending_txn[\"pool-error\"]))\n\n        lastStatus = client.status_after_block(lastRound + 1)\n\n        lastRound += 1\n\n    raise Exception(\n        \"Transaction {} not confirmed after {} rounds\".format(txID, timeout)\n    )\n\n\ndef fullyCompileContract(client: AlgodClient, contract: Expr) -> bytes:\n    teal = compileTeal(contract, mode=Mode.Application, version=5)\n    response = client.compile(teal)\n    return b64decode(response[\"result\"])\n\n\ndef decodeState(stateArray: List[Any]) -> Dict[bytes, Union[int, bytes]]:\n    state: Dict[bytes, Union[int, bytes]] = dict()\n\n    for pair in stateArray:\n        key = b64decode(pair[\"key\"])\n\n        value = pair[\"value\"]\n        valueType = value[\"type\"]\n\n        if valueType == 2:\n            # value is uint64\n            value = value.get(\"uint\", 0)\n        elif valueType == 1:\n            # value is byte array\n            value = b64decode(value.get(\"bytes\", \"\"))\n        else:\n            raise Exception(f\"Unexpected state type: {valueType}\")\n\n        state[key] = value\n\n    return state\n\n\ndef getAppGlobalState(\n    client: AlgodClient, appID: int\n) -> Dict[bytes, Union[int, bytes]]:\n    appInfo = client.application_info(appID)\n    return decodeState(appInfo[\"params\"][\"global-state\"])\n\n\ndef getBalances(client: AlgodClient, account: str) -> Dict[int, int]:\n    balances: Dict[int, int] = dict()\n\n    accountInfo = client.account_info(account)\n\n    # set key 0 to Algo balance\n    balances[0] = accountInfo[\"amount\"]\n\n    assets: List[Dict[str, Any]] = accountInfo.get(\"assets\", [])\n    for assetHolding in assets:\n        assetID = assetHolding[\"asset-id\"]\n        amount = assetHolding[\"amount\"]\n        balances[assetID] = amount\n\n    return balances\n\n\ndef getLastBlockTimestamp(client: AlgodClient) -> Tuple[int, int]:\n    status = client.status()\n    lastRound = status[\"last-round\"]\n    block = client.block_info(lastRound)\n    timestamp = block[\"block\"][\"ts\"]\n\n    return block, timestamp\n"
                }
            ]
        },
        {
            "name": "example.py",
            "content": "from time import time, sleep\n\nfrom algosdk import account, encoding\nfrom algosdk.logic import get_application_address\nfrom auction.operations import createAuctionApp, setupAuctionApp, placeBid, closeAuction\nfrom auction.util import (\n    getBalances,\n    getAppGlobalState,\n    getLastBlockTimestamp,\n)\nfrom auction.testing.setup import getAlgodClient\nfrom auction.testing.resources import (\n    getTemporaryAccount,\n    optInToAsset,\n    createDummyAsset,\n)\n\n\ndef simple_auction():\n    client = getAlgodClient()\n\n    print(\"Generating temporary accounts...\")\n    creator = getTemporaryAccount(client)\n    seller = getTemporaryAccount(client)\n    bidder = getTemporaryAccount(client)\n\n    print(\"Alice (seller account):\", seller.getAddress())\n    print(\"Bob (auction creator account):\", creator.getAddress())\n    print(\"Carla (bidder account)\", bidder.getAddress(), \"\\n\")\n\n    print(\"Alice is generating an example NFT...\")\n    nftAmount = 1\n    nftID = createDummyAsset(client, nftAmount, seller)\n    print(\"The NFT ID is\", nftID)\n    print(\"Alice's balances:\", getBalances(client, seller.getAddress()), \"\\n\")\n\n    startTime = int(time()) + 10  # start time is 10 seconds in the future\n    endTime = startTime + 30  # end time is 30 seconds after start\n    reserve = 1_000_000  # 1 Algo\n    increment = 100_000  # 0.1 Algo\n    print(\"Bob is creating an auction that lasts 30 seconds to auction off the NFT...\")\n    appID = createAuctionApp(\n        client=client,\n        sender=creator,\n        seller=seller.getAddress(),\n        nftID=nftID,\n        startTime=startTime,\n        endTime=endTime,\n        reserve=reserve,\n        minBidIncrement=increment,\n    )\n    print(\n        \"Done. The auction app ID is\",\n        appID,\n        \"and the escrow account is\",\n        get_application_address(appID),\n        \"\\n\",\n    )\n\n    print(\"Alice is setting up and funding NFT auction...\")\n    setupAuctionApp(\n        client=client,\n        appID=appID,\n        funder=creator,\n        nftHolder=seller,\n        nftID=nftID,\n        nftAmount=nftAmount,\n    )\n    print(\"Done\\n\")\n\n    sellerBalancesBefore = getBalances(client, seller.getAddress())\n    sellerAlgosBefore = sellerBalancesBefore[0]\n    print(\"Alice's balances:\", sellerBalancesBefore)\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < startTime + 5:\n        sleep(startTime + 5 - lastRoundTime)\n    actualAppBalancesBefore = getBalances(client, get_application_address(appID))\n    print(\"Auction escrow balances:\", actualAppBalancesBefore, \"\\n\")\n\n    bidAmount = reserve\n    bidderBalancesBefore = getBalances(client, bidder.getAddress())\n    bidderAlgosBefore = bidderBalancesBefore[0]\n    print(\"Carla wants to bid on NFT, her balances:\", bidderBalancesBefore)\n    print(\"Carla is placing bid for\", bidAmount, \"microAlgos\")\n\n    placeBid(client=client, appID=appID, bidder=bidder, bidAmount=bidAmount)\n\n    print(\"Carla is opting into NFT with ID\", nftID)\n\n    optInToAsset(client, nftID, bidder)\n\n    print(\"Done\\n\")\n\n    _, lastRoundTime = getLastBlockTimestamp(client)\n    if lastRoundTime < endTime + 5:\n        waitTime = endTime + 5 - lastRoundTime\n        print(\"Waiting {} seconds for the auction to finish\\n\".format(waitTime))\n        sleep(waitTime)\n\n    print(\"Alice is closing out the auction\\n\")\n    closeAuction(client, appID, seller)\n\n    actualAppBalances = getBalances(client, get_application_address(appID))\n    expectedAppBalances = {0: 0}\n    print(\"The auction escrow now holds the following:\", actualAppBalances)\n    assert actualAppBalances == expectedAppBalances\n\n    bidderNftBalance = getBalances(client, bidder.getAddress())[nftID]\n    assert bidderNftBalance == nftAmount\n\n    actualSellerBalances = getBalances(client, seller.getAddress())\n    print(\"Alice's balances after auction: \", actualSellerBalances, \" Algos\")\n    actualBidderBalances = getBalances(client, bidder.getAddress())\n    print(\"Carla's balances after auction: \", actualBidderBalances, \" Algos\")\n    assert len(actualSellerBalances) == 2\n    # seller should receive the bid amount, minus the txn fee\n    assert actualSellerBalances[0] >= sellerAlgosBefore + bidAmount - 1_000\n    assert actualSellerBalances[nftID] == 0\n\n\nsimple_auction()\n"
        },
        {
            "name": "mypy.ini",
            "content": "[mypy]\n\n[mypy-pytest.*]\nignore_missing_imports = True\n\n[mypy-algosdk.*]\nignore_missing_imports = True\n"
        },
        {
            "name": "requirements.txt",
            "content": "pyteal==0.9.1\npy-algorand-sdk==1.8.0\nmypy==0.910\npytest\nblack==21.7b0\n"
        },
        {
            "name": "sandbox",
            "content": "#!/usr/bin/env bash\nset -e\n\nPARENT_DIR=$( cd \"$(dirname \"${BASH_SOURCE[0]}\")\" ; pwd -P )\nSANDBOX_DIR=$PARENT_DIR/_sandbox\nif [ ! -d \"$SANDBOX_DIR\" ]; then\n    echo \"Pulling sandbox...\"\n    git clone https://github.com/algorand/sandbox.git $SANDBOX_DIR\nfi\n\n$SANDBOX_DIR/sandbox \"$@\"\n"
        }
    ]
}